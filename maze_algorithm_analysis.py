'''
NCLab Capstone Project

Jolene Williams

maze_algorithm_analysis.py
Main function for the program. 

'''
import matplotlib.pyplot as plt
import sys
import seaborn as sns
import pandas as pd
from time import perf_counter
import gc
import random as rn

'''File imports'''
from maze_generation import generate_maze
from A_star_algorithm import a_star_find_path
from DFS_algorithm import dfs_find_path
from BFS_algorithm import bfs_find_path


'''Helper Functions'''

def generate_maze_id():
    '''Generate unique ID for each maze'''

    l_1 = rn.choice(range(65,91))
    l_2 = rn.choice(range(0,10))
    l_3 = rn.choice(range(65,91))
    l_4 = rn.choice(range(0,10))

    string_result = chr(l_1) + str(l_2) + chr(l_3) + str(l_4)

    return string_result

def create_maze_plot(maze_array):
    '''Create maze plot, returns imshow object'''
    pass


def visualize_performance_data(df, ax):
    '''Visualize the performance data with bar graphs'''

    # Get axes objects for each bar graph
    node_visitations_bargraph = ax[1,0]
    execution_times_bargraph = ax[1,2]
    
    # Make labels bold for readability
    for label in node_visitations_bargraph.get_yticklabels():
        label.set_fontweight('bold')
    for label in execution_times_bargraph.get_xticklabels():
        label.set_fontweight('bold')

    # Bar graph for total node visitations per algorithm
    sns.barplot(ax=node_visitations_bargraph,y='algorithm_title', x='node_visitations', hue='algorithm_title', data=df, width=0.4)
    node_visitations_bargraph.set_ylabel("", fontsize=8)
    node_visitations_bargraph.set_xlabel("Node Visitations", fontsize=10, fontweight='bold')

    # Bar graph for execution time per algorithm
    sns.barplot(ax=execution_times_bargraph, x='algorithm_title', y= 'execution_time',hue='algorithm_title',data=df, width=0.4)
    execution_times_bargraph.set_xlabel("", fontsize=8)
    execution_times_bargraph.set_ylabel("Execution Time (seconds)", fontsize=10, fontweight='bold')
    

def visualize_all_mazes(maze_array, maze_paths, ax):
    '''Visualize all three mazes along with each algorithm's solution path'''

    # Get paths generated by each algorithm
    astar_path, dfs_path, bfs_path = maze_paths
    
    # Give each algorithm an axes object
    astar_ax, dfs_ax, bfs_ax = ax[0,0], ax[0,1], ax[0,2]

    # Visualize each maze
    visualize_maze(maze_array, astar_path, 'green', 'A* Algorithm',  astar_ax)
    visualize_maze(maze_array, dfs_path, 'red', 'DFS Algorithm',  dfs_ax)
    visualize_maze(maze_array, bfs_path, 'blue', 'BFS Algorithm', bfs_ax)


def collect_data(algorithm_titles:list, path_lengths:list, execution_times:list):
    '''Collect data for data analysis/ visualization'''

    df = pd.DataFrame()

    df['execution_time'] = execution_times
    df['node_visitations'] = path_lengths
    df['algorithm_title'] = algorithm_titles

    return df


def visualize_maze(maze_array, path, color, alg, axes):
    '''Visualize the maze and the path of each algorithm's maze solution'''

    # Get the line representing the algorithm's solution path
    path_row_vals = [row for (row, item) in path]
    path_item_vals = [item for (row, item) in path]

    # Display maze
    axes.imshow(maze_array, cmap='Blues', origin='upper')

    # Plot the algorithm's path
    axes.plot(path_item_vals, path_row_vals, color=color, lw=1.5, label=alg)

    # other settings
    axes.set_xticks([])
    axes.set_yticks([])
    axes.legend()

'''Main Function'''

def maze_algorithm_analysis():
    '''Main function of the program. Generate a maze, solve using three algorithms, 
    show the mazes and each algorithm's solution, then visualize the performance data with bar graphs'''

    # Generate the maze
    maze_array, start, goal = generate_maze(30,40)
    maze_id = generate_maze_id()

    # Generate each algorithm's solution to the maze and record execution time data for each function call
    a_et_start = perf_counter()
    astar_path = a_star_find_path(maze_array, start, goal)
    a_et_end = perf_counter()

    dfs_et_start = perf_counter()
    dfs_path = dfs_find_path(maze_array, start, goal)
    dfs_et_end = perf_counter()

    bfs_et_start = perf_counter()
    bfs_path = bfs_find_path(maze_array, start, goal)
    bfs_et_end = perf_counter()

    # If the algorithm was not able to find a path, give an empty placeholder path
    if not astar_path:
        astar_path = [(0,0)]
    if not bfs_path:
        bfs_path = [(0,0)]
    if not dfs_path:
        dfs_path = [(0,0)]

    # Create figure to visualize the mazes and performance data
    fig, ax = plt.subplots(figsize=(10,8),nrows=2, ncols=3, height_ratios=[5,2])
    fig.suptitle(f'Solution Paths and Performance Data for Maze {maze_id}', fontweight='bold',fontsize=20)
    ax[1,1].remove()

    # Visualize the maze along with each algorithm's solution
    maze_paths = (astar_path, dfs_path, bfs_path)
    visualize_all_mazes(maze_array, maze_paths, ax)
    
    # Record performance data in dataframe
    df = collect_data(['A*', 'DFS', 'BFS'],[len(astar_path), len(dfs_path), len(bfs_path)], 
                      [(a_et_end - a_et_start), (dfs_et_end - dfs_et_start), (bfs_et_end - bfs_et_start)])

    # Visualize the performance data in bar graphs
    visualize_performance_data(df, ax)
    
    # Save the data to file
    fig.tight_layout()
    #plt.show()
    filename = f'algorithm_analysis_for_maze_{maze_id}.png'
    plt.savefig(filename, dpi=500)

    # Memory clean up
    plt.close(fig)
    gc.collect()

    return maze_id, filename
    
if __name__ == "__main__":
    place_holder_id, place_holder_filen = maze_algorithm_analysis()