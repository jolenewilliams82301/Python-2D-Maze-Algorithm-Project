"""
File: main.py
Author: Jolene Williams
Description: Main file for program. Generates maze, 
generates each pathfinding algorithm's solution, visualizes each algorithm's 
solution and performance data with Matplotlib.

NCLab Capstone Project 1

"""

import matplotlib.pyplot as plt
import pandas as pd
from time import perf_counter
import gc
import random as rn
import matplotlib.patches as mpatches
from maze_generation import generate_maze
from DFS_algorithm import dfs_find_path
from BFS_algorithm import bfs_find_path
from A_star_algorithm import a_star_find_path


def generate_maze_id():
    ''' Generate unique ID for each maze.

        Keyword arguments:
        None
    '''
    l_1 = rn.choice(range(4500,7000))

    string_result = hex(l_1)[::-1]

    return string_result


def collect_data(algorithm_titles:list, path_lengths:list, execution_times:list):
    ''' Collect the performance data for each algorithm. Return as a DataFrame

        Keyword arguments:
        algorithm_titles -- list of strings, name of each algorithm
        path_lengths -- list of integers, length of each algorithm's solution path
        execution_times -- list of floats, execution time of each algorithm
    '''
    df = pd.DataFrame()

    df['execution_time'] = execution_times
    df['node_visitations'] = path_lengths
    df['algorithm_title'] = algorithm_titles

    return df


def visualize_performance_data(df, ax):
    ''' Visualize the performance data, number of steps and execution time, as bar graphs

        Keyword arguments:
        df -- dataframe containing performance data
        ax -- axes object of the main figure
    '''
    # Get axes objects for each bar graph
    node_visitations_bargraph = ax[1,0]
    execution_times_bargraph = ax[1,2]
    
    # Make labels bold for readability
    for label in node_visitations_bargraph.get_xticklabels():
        label.set_fontweight('bold')
    for label in execution_times_bargraph.get_xticklabels():
        label.set_fontweight('bold')

    # Set colors
    bar_colors = ['limegreen', 'mediumblue', 'orangered']

    # Bar graph for total node visitations per algorithm
    node_visitations_bargraph.bar(df['algorithm_title'],df['node_visitations'],  color=bar_colors,width=0.4)
    node_visitations_bargraph.set_xlabel("")
    node_visitations_bargraph.set_ylabel("Steps", fontsize=10,fontweight='bold')

    # Bar graph for execution time per algorithm
    execution_times_bargraph.bar(df['algorithm_title'],df['execution_time'],color=bar_colors,width=0.4)
    execution_times_bargraph.set_xlabel("", fontsize=8)
    execution_times_bargraph.set_ylabel("Execution Time (seconds)", fontsize=10, fontweight='bold')
    

def visualize_all_mazes(maze_array, maze_paths, ax, maze_id):
    ''' Visualize all of the mazes

        Keyword arguments:
        maze_array -- 2d numpy array representing the generated maze
        maze_paths -- list containing the solution paths of each algorithm
        ax -- axes object of the main figure
        maze_id -- the unique ID assigned to the generated maze
    '''
    # Get paths generated by each algorithm
    astar_path, dfs_path, bfs_path = maze_paths
    
    # Give each algorithm an axes object
    astar_ax, dfs_ax, bfs_ax = ax[0,0], ax[0,1], ax[0,2]

    # Visualize each algorithm's solution path
    visualize_maze(maze_array, astar_path, 'limegreen', 'A* Algorithm',  astar_ax)
    visualize_maze(maze_array, dfs_path, 'mediumblue', 'DFS Algorithm',  dfs_ax)
    visualize_maze(maze_array, bfs_path, 'orangered', 'BFS Algorithm', bfs_ax)

    # Visualize the generated maze
    ax[1,1].imshow(maze_array, cmap='Greys', origin='upper')
    ax[1,1].set_xticks([])
    ax[1,1].set_yticks([])
    red_patch = mpatches.Patch(color='grey', label='Start')
    black_patch = mpatches.Patch(color='Black', label='Goal')
    ax[1,1].legend(handles=[red_patch,black_patch],bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)
    ax[1,1].set_xlabel(f"Maze {maze_id}", fontsize=10,fontweight='bold')


def visualize_maze(maze_array, path, color, alg, axes):
    ''' Visualize a given algorithm's solution path on the maze

        Keyword arguments:
        maze_array -- 2d numpy array representing the generated maze
        path -- solution path generated by the algorithm
        color -- color used to distinguish to the algorithm
        alg -- string of algorithm title used for legend 
        axes -- axes object of the main figure
    '''
    if path:

        # Get the line representing the algorithm's solution path
        path_row_vals = [row for (row, item) in path]
        path_item_vals = [item for (row, item) in path]

        # Display maze
        axes.imshow(maze_array, cmap='Greys', origin='upper')

        # Plot the algorithm's path
        axes.plot(path_item_vals, path_row_vals, color=color, lw=2, label=alg)

        # other settings
        axes.set_xticks([])
        axes.set_yticks([])
        
    else:
        axes.imshow(maze_array, cmap='Greys', origin='upper')

        # other settings
        axes.set_xticks([])
        axes.set_yticks([])


def maze_algorithm_analysis():
    ''' Main function for the project. Randomly generates a maze, generates each algorithm's solution to the maze,
        collects the performance data for each algorithm, visualizes each algorithm's solution path
        and visualizes the performance data in bar graphs.

        Keyword arguments:
        None
    '''
    # Generate the maze
    maze_array, start, goal = generate_maze(30,30)
    maze_id = generate_maze_id()

    # Generate each algorithm's solution to the maze and record execution time 
    a_et_start = perf_counter()
    astar_path = a_star_find_path(maze_array, start, goal)
    a_et_end = perf_counter()

    dfs_et_start = perf_counter()
    dfs_path = dfs_find_path(maze_array, start, goal)
    dfs_et_end = perf_counter()

    bfs_et_start = perf_counter()
    bfs_path = bfs_find_path(maze_array, start, goal)
    bfs_et_end = perf_counter()

    # If the algorithm was not able to find a path, give an empty placeholder path
    if not astar_path:
        astar_path = [(0,0)]
    if not bfs_path:
        bfs_path = [(0,0)]
    if not dfs_path:
        dfs_path = [(0,0)]

    # Create figure to visualize the mazes and performance data
    fig, ax = plt.subplots(figsize=(8,6),nrows=2, ncols=3, height_ratios=[3,2])
    fig.suptitle(f'Maze {maze_id}: Solution Paths and Algorithm Performance Data', fontweight='bold',fontsize=15)
    
    # Visualize the generated maze along with each algorithm's solution to the maze
    maze_paths = (astar_path, dfs_path, bfs_path)
    visualize_all_mazes(maze_array, maze_paths, ax, maze_id)
    fig.legend(loc='outside upper right')

    # Record performance data in dataframe
    df = collect_data(['A*', 'DFS', 'BFS'],[len(astar_path), len(dfs_path), len(bfs_path)], 
                      [(a_et_end - a_et_start), (dfs_et_end - dfs_et_start), (bfs_et_end - bfs_et_start)])

    # Visualize the performance data in bar graphs
    visualize_performance_data(df, ax)
    
    # Save the data to file
    fig.tight_layout()
    plt.show()

    # Memory clean up
    del fig, ax, df
    garb_collect = gc.collect()

    return maze_id, garb_collect

if __name__ == "__main__":
    
    # Entry point for the program
    print('-----------------------------------------------------------')
    print("Python Pathfinding Algorithm Analysis using 2D Mazes")
    print("NCLab Capstone Project 1 for Python Developer Course")
    print("Jolene Williams")
    print('-----------------------------------------------------------')
    print("Generating maze and algorithm performance data ...")
    id,garb_collect = maze_algorithm_analysis()
    print(f"Generated Maze {id} with algorithm performance data. Run program again to generate a new maze.")